<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <link rel="stylesheet" href="https://cdn.webrtc-experiment.com/style.css">

    <meta name="keywords" content="WebRTC,RTCMultiConnection,Demos,Experiments,Samples,Examples" />

    <style>
        html, body {
            height: 100%;
            margin: 0;
        }
        .container
        {
            text-align: center;
            padding: 1rem;
            box-sizing: border-box;
            height: 100%;
        }

        .container video
        {
            width: 80%;
            max-height: 100%;
            height: auto;
        }

        .controls {
            position: absolute;
            bottom: 1rem;
        }
        .controls button {
            margin: 0.5rem;
        }
        #video-previewWebCam {
            position: absolute;
            display: none;
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
        }
        #audio-player {
            position: absolute;
            display: none;
            bottom: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
        }
        audio {
            display: none;
        }
    </style>
</head>

<body>

        <div class="container">
            <video id="video-preview"  loop></video>
            <video id="video-previewWebCam"  loop></video>
            <video id="audio-player"  loop></video>
            <div class="controls">
                <button id="webcam-on">On Webcam+audio</button>
                <button id="webcam-off">Off Webcam+audio</button>
            </div>
        </div>
        <script src="https://rtcmulticonnection.herokuapp.com/socket.io/socket.io.js"></script>

        <script>
            window.getExternalIceServers = false;
        </script>

        <script src="rmc3.js"></script>



        <script>
            var serverIp = '163.172.27.226';
            // If client is coordinator
            var coordinatorConnection = null;
            // Main conection screensharing
            var connection = null;
            // Webcam connection
            var webCamConnection = null;

            var remote = require('electron').remote;
            const dialog = require('electron').remote.dialog;
            var devServerIp = remote.getGlobal('sharedObj').serverIp;
            var coordConnName = remote.getGlobal('sharedObj').coordConnectionName;
            if (devServerIp !== '' && devServerIp !== "163.172.27.226") {
                serverIp = devServerIp;
                dialog.showMessageBox({type: 'info', message: "USING CUSTOM SERVER. SERVER IP:"+devServerIp, title: 'Demio', buttons: ['Ok']});
            }

            var audioPreviewCoord = document.getElementById('audio-player');
            var videoPreview = document.getElementById('video-preview');
            var videoPreviewWebCam = document.getElementById('video-previewWebCam');

            var broadcastSources = {
                "demiotest": videoPreview,
                "demiotestA": videoPreviewWebCam,
                "coordinator": audioPreviewCoord
            };

            var ignoreCoordNumber = 0;

            // Connections for coordinators
            var coordinators = [];
            var openedCoordinatorsNames = [];
            var openedcoordinators = [];


            document.getElementById('webcam-on').onclick = function() {
                this.disabled = true;
                webCamConnection.dontCaptureUserMedia = false;
                webCamConnection.attachStreams.forEach(function(stream) {
                    stream.unmute();
                    webCamConnection.getSocket().emit('unmute-webcam');
                });
                document.getElementById('webcam-off').disabled = false;
            };
            document.getElementById('webcam-off').onclick = function() {
                this.disabled = true;
                if(webCamConnection.attachStreams.length) {
                    webCamConnection.attachStreams.forEach(function(stream) {
                        stream.mute();
                        webCamConnection.getSocket().emit('mute-webcam');
                    });
                }
                document.getElementById('webcam-on').disabled = false;
            };


            var splittedCoordName = coordConnName.split('_');
            var ignoreCoordNumber = parseInt(splittedCoordName[splittedCoordName.length-1]);

            function buildCoordList() {
                for (i=1; i<=10; i++) {
                    if ( i !== ignoreCoordNumber ) {
                        openedCoordinatorsNames.push("demio_coordinator_"+i);
                    }
                }
            }

            var joinOrOpenBroadcast = function(currentConnection, withAudio, withVideo, withScreen, bcastId, start) {
                var broadcastId = bcastId;
                this.disabled = true;

                if (withAudio && !withVideo && !withScreen) {
                    currentConnection.session = {
                        audio: true,
                        oneway: true
                    };
                }
                if (withVideo && !withScreen && !withAudio) {
                    currentConnection.session = {
                        video: true,
                        audio: true,
                        oneway: true
                    };
                }
                if (withScreen && !withAudio && !withVideo) {
                    currentConnection.session = {
                        screen: true,
                        oneway: true
                    };
                }

                var socket = currentConnection.getSocket();

                socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                    if (start) {
                        if(!isBroadcastExists) {
                            // the first person (i.e. real-broadcaster) MUST set his user-id
                            currentConnection.userid = broadcastId;
                        }
                        if (isBroadcastExists) {
                            dialog.showMessageBox({type: 'info', message: 'Broadcast already in use', title: 'Demio', buttons: ['Ok']});
                            return;
                        }
                    }

                    if (!start) {
                        if(!isBroadcastExists) {
                            return;
                        }
                    }


                    console.log('check-broadcast-presence', broadcastId, isBroadcastExists);

                    socket.emit('join-broadcast', {
                        broadcastId: broadcastId,
                        userid: currentConnection.userid,
                        typeOfStreams: currentConnection.session
                    });
                });
            }

            var preview = null;

            var onleaveEvent = function(event) {
                if(event.userid !== broadcastSources[event.extra['stream_name']].userid) return;

                var socket = this.getSocket();
                socket.emit('can-not-relay-broadcast');

                this.isUpperUserLeft = true;

            };

            var onstreamEvent = function(event) {
                if(this.isInitiator && event.type !== 'local') {
                    return;
                }

                if(event.mediaElement) {
                    event.mediaElement.pause();
                    delete event.mediaElement;
                }

                this.isUpperUserLeft = false;

                broadcastSources[event.extra['stream_name']].src = URL.createObjectURL(event.stream);
                broadcastSources[event.extra['stream_name']].play();

                broadcastSources[event.extra['stream_name']].userid = event.userid;

                if(event.type === 'local') {
                    broadcastSources[event.extra['stream_name']].muted = true;
                }

                if (this.isInitiator == false && event.type === 'remote') {
                    this.dontCaptureUserMedia = true;
                    this.attachStreams = [event.stream];
                    this.sdpConstraints.mandatory = {
                        OfferToReceiveAudio: false,
                        OfferToReceiveVideo: false
                    };

                    var socket = this.getSocket();
                    socket.emit('can-relay-broadcast');

                    if(this.DetectRTC.browser.name === 'Chrome') {
                        this.getAllParticipants().forEach(function(p) {
                            if(p + '' != event.userid + '') {
                                var peer = this.peers[p].peer;
                                peer.getLocalStreams().forEach(function(localStream) {
                                    peer.removeStream(localStream);
                                });
                                peer.addStream(event.stream);
                                this.dontAttachStream = true;
                                this.renegotiate(p);
                                this.dontAttachStream = false;
                            }
                        });
                    }

                    if(this.DetectRTC.browser.name === 'Firefox') {
                        this.getAllParticipants().forEach(function(p) {
                            if(p + '' != event.userid + '') {
                                this.replaceTrack(event.stream, p);
                            }
                        });
                    }

                }
            };


            var connectToSocket = function(currentConnection, isScreen) {
                currentConnection.connectSocket(function(socket) {
                    socket.on('logs', function(log) {
                        console.log(log);
                    });


                    // this event is emitted when a broadcast is already created.
                    socket.on('join-broadcaster', function(hintsToJoinBroadcast) {
                        console.log('join-broadcaster', hintsToJoinBroadcast);

                        currentConnection.session = hintsToJoinBroadcast.typeOfStreams;
                        currentConnection.sdpConstraints.mandatory = {
                            OfferToReceiveVideo: !!currentConnection.session.video,
                            OfferToReceiveAudio: !!currentConnection.session.audio
                        };
                        currentConnection.join(hintsToJoinBroadcast.userid);
                    });

                    socket.on('rejoin-broadcast', function(broadcastId) {
                        console.log('rejoin-broadcast', broadcastId);

                        currentConnection.attachStreams = [];
                        socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                            if(!isBroadcastExists) {
                                currentConnection.userid = broadcastId;
                            }

                            socket.emit('join-broadcast', {
                                broadcastId: broadcastId,
                                userid: currentConnection.userid,
                                typeOfStreams: currentConnection.session
                            });
                        });
                    });

                    socket.on('broadcast-stopped', function(broadcastId) {
                        console.error('broadcast-stopped', broadcastId);
                        if (isScreen) {
                            dialog.showMessageBox({type: 'info', message: 'This broadcast has been stopped', title: 'Demio', buttons: ['Ok']});
                        }
                    });

                    socket.on('start-broadcasting', function(typeOfStreams) {
                        console.log('start-broadcasting', typeOfStreams);

                        currentConnection.sdpConstraints.mandatory = {
                            OfferToReceiveVideo: false,
                            OfferToReceiveAudio: false
                        };
                        currentConnection.session = typeOfStreams;

                        currentConnection.open(currentConnection.userid);
                    });
                });
                return currentConnection;
            }

            var findCoordinators = function(callback) {
              setTimeout(function() {
                buildCoordList();
                applyCoords();
                callback();
              }, 200);
            };

            var checkBroadcasts = function() {
              openedcoordinators.forEach(function (coord, i) {
                coord = connectToSocket(coord, false);
                coord.onstream = onstreamEvent;
                // joinOrOpenBroadcast function(currentConnection, withAudio, withVideo, withScreen, bcastId, isCoordinator, start?)
                joinOrOpenBroadcast(coord, true, false, false, openedCoordinatorsNames[i], false);
              });
            };

            function applyCoords() {
                openedCoordinatorsNames.forEach(function(name) {
                    cConnection = setupConnection();
                    openedcoordinators.push(cConnection);
                });
            }

            var speed = remote.getGlobal('sharedObj').speed;
            function getPeersCount() {
                speed *= 8; // to kilobits

                peerCount = Math.floor(speed/1024);

                if (peerCount < 1) {
                    // each relaying-user should serve only 1 users
                    peerCount = 0;
                }
                if (peerCount > 5) {
                    peerCount = 5;
                }
                return peerCount;
            }


            function setupConnection() {
                var connection = new RTCMultiConnection(null, {
                    useDefaultDevices: true // if we don't need to force selection of specific devices
                });
                connection.enableScalableBroadcast = true;
                connection.maxRelayLimitPerUser = 5;
                connection.autoCloseEntireSession = true;
                connection.socketURL = 'https://'+serverIp+':9001/';
                connection.getExternalIceServers = false;
                var iceServers = [];
                iceServers.push({
                    url: 'turn:'+serverIp+':3478',
                    username: 'demio',
                    credential: 'demiotest'
                });
                connection.iceServers = iceServers;

                connection.processSdp = function(sdp) {
                    var bandwidth = {
                        screen: 1024, // 300kbits minimum
                        audio: 128,   // 50kbits  minimum
                        video: 512   // 256kbits (both min-max)
                    };
                    var isScreenSharing = true;

                    sdp = BandwidthHandler.setApplicationSpecificBandwidth(sdp, bandwidth, isScreenSharing);
                    sdp = BandwidthHandler.setVideoBitrates(sdp, {
                         min: 512,
                         max: 4096
                    });
                    sdp = BandwidthHandler.setOpusAttributes(sdp);

                    return sdp;
                };

                connection.socketMessageEvent = 'scalable-screen-broadcast-demo';
                return connection;
            }




            if (coordConnName !== '') {
                coordinatorConnection = setupConnection();
                coordinatorConnection = connectToSocket(coordinatorConnection, false);

                coordinatorConnection.onstream = onstreamEvent;
                coordinatorConnection.onleave = onleaveEvent;
                coordinatorConnection.extra['stream_name'] = 'coordinator';
                coordinatorConnection.userid = coordConnName;
                // joinOrOpenBroadcast function(currentConnection, withAudio, withVideo, withScreen, bcastId, start?)
                joinOrOpenBroadcast(coordinatorConnection, true, false, false, coordConnName, true);
            }


            // Setup main connection
            connection = setupConnection();
            var mainWindow = remote.getCurrentWindow()
            mainWindow.setTitle("Demio Broadcast");
            connection = connectToSocket(connection, true);
            connection.getSocket().on('new-coordinator', function(coordinatorName) {
                    console.log("New coordinator: "+coordinatorName);
                    newCoordinator = setupConnection();
                    newCoordinator = connectToSocket(newCoordinator, false);
                    // joinOrOpenBroadcast function(currentConnection, withAudio, withVideo, withScreen, bcastId, isCoordinator, start?)
                    joinOrOpenBroadcast(newCoordinator, true, false, false, coordinatorName, false);
                    coordinators.push(newCoordinator);
            });
            connection.onstream = onstreamEvent;
            connection.onleave = onleaveEvent;
            connection.extra['stream_name'] = 'demiotest';


            // Setup webcam connection
            webCamConnection = setupConnection();
            webCamConnection = connectToSocket(webCamConnection, false);
            webCamConnection.onstream = onstreamEvent;
            webCamConnection.onleave = onleaveEvent;
            webCamConnection.extra['stream_name'] = 'demiotestA';
            webCamConnection.onmute = function() {
                document.getElementById('video-previewWebCam').style.display = 'none';
            }
            webCamConnection.onunmute = function() {
                document.getElementById('video-previewWebCam').style.display = 'block';
            }
            webCamConnection.onopen = function() {
                if (webCamConnection.alreadyOpened) return;
                document.getElementById('webcam-on').disabled = false;
            }


            joinOrOpenBroadcast(connection, false, false, true, 'demiotest', true);
            joinOrOpenBroadcast(webCamConnection, false, true, false, 'demiotestA', true);

        </script>



</body>

</html>

